const std = @import("std");

pub const Chip = enum {
    rp2040,
    rp2350,
};

pub const CpuArch = enum {
    arm,
    riscv,
};

pub fn build(b: *std.Build) void {
    const chip = b.option(Chip, "chip", "Target chip (rp2040 or rp2350)") orelse .rp2040;
    const cpu_arch = b.option(CpuArch, "cpu_arch", "CPU architecture (arm or riscv, rp2350 only)") orelse .arm;
    const board = b.option([]const u8, "board", "Target board (e.g., pico, pico_w, pico2)") orelse switch (chip) {
        .rp2040 => "pico",
        .rp2350 => "pico2",
    };

    const target_query = getTarget(chip, cpu_arch);
    const target = b.resolveTargetQuery(target_query);
    const optimize = b.standardOptimizeOption(.{});

    // Generate required config headers
    const generated = generateConfigHeaders(b, chip, board);

    // Install headers for downstream use
    b.getInstallStep().dependOn(&b.addInstallDirectory(.{
        .source_dir = generated,
        .install_dir = .header,
        .install_subdir = "",
    }).step);

    // Install SDK source headers
    installSdkHeaders(b);

    // Create an example/test library to verify the build works
    const example_lib = createExampleLibrary(b, target, optimize, chip, board, generated);
    b.installArtifact(example_lib);
}

fn generateConfigHeaders(b: *std.Build, chip: Chip, board: []const u8) std.Build.LazyPath {
    const wf = b.addWriteFiles();

    // Generate pico/version.h
    _ = wf.add("pico/version.h",
        \\/*
        \\ * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
        \\ *
        \\ * SPDX-License-Identifier: BSD-3-Clause
        \\ */
        \\
        \\// THIS FILE IS AUTOGENERATED; DO NOT EDIT
        \\
        \\#ifndef _PICO_VERSION_H
        \\#define _PICO_VERSION_H
        \\
        \\#define PICO_SDK_VERSION_MAJOR    2
        \\#define PICO_SDK_VERSION_MINOR    2
        \\#define PICO_SDK_VERSION_REVISION 0
        \\#define PICO_SDK_VERSION_STRING   "2.2.0"
        \\
        \\#endif
        \\
    );

    // Generate pico_config_extra_headers.h (empty by default)
    _ = wf.add("pico_config_extra_headers.h",
        \\// Extra headers - add custom includes here if needed
        \\
    );

    // Generate pico_config_platform_headers.h based on board and chip
    const platform_header = switch (chip) {
        .rp2040 => b.fmt(
            \\// Platform headers for RP2040
            \\#include "cmsis/rename_exceptions.h"
            \\#include "boards/{s}.h"
            \\
        , .{board}),
        .rp2350 => b.fmt(
            \\// Platform headers for RP2350
            \\#include "cmsis/rename_exceptions.h"
            \\#include "boards/{s}.h"
            \\
        , .{board}),
    };
    _ = wf.add("pico_config_platform_headers.h", platform_header);

    // Generate pico/config_autogen.h
    _ = wf.add("pico/config_autogen.h",
        \\// AUTOGENERATED - DO NOT EDIT
        \\//
        \\// This header includes platform and extra configuration headers.
        \\
        \\// Extra headers (custom user configuration)
        \\#include "pico_config_extra_headers.h"
        \\
        \\// Platform-specific headers (board and chip configuration)
        \\#include "pico_config_platform_headers.h"
        \\
    );

    return wf.getDirectory();
}

fn installSdkHeaders(b: *std.Build) void {
    // Install common headers
    const common_header_dirs = [_][]const u8{
        "src/common/pico_base_headers/include",
        "src/common/pico_binary_info/include",
        "src/common/pico_bit_ops_headers/include",
        "src/common/pico_divider_headers/include",
        "src/common/pico_sync/include",
        "src/common/pico_time/include",
        "src/common/pico_util/include",
        "src/common/pico_stdlib_headers/include",
        "src/common/hardware_claim/include",
        "src/boards/include",
    };

    for (common_header_dirs) |dir| {
        b.getInstallStep().dependOn(&b.addInstallDirectory(.{
            .source_dir = b.path(dir),
            .install_dir = .header,
            .install_subdir = "",
        }).step);
    }
}

fn createExampleLibrary(
    b: *std.Build,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    chip: Chip,
    board: []const u8,
    generated: std.Build.LazyPath,
) *std.Build.Step.Compile {
    // Create a minimal stub source file for the library
    const stub_wf = b.addWriteFiles();
    const stub_source = stub_wf.add("pico_sdk_stub.c",
        \\// Minimal stub to create a valid library artifact
        \\// Real SDK functionality comes from linking individual source files
        \\
        \\#include "pico/version.h"
        \\
        \\const int pico_sdk_version_major = PICO_SDK_VERSION_MAJOR;
        \\const int pico_sdk_version_minor = PICO_SDK_VERSION_MINOR;
        \\const int pico_sdk_version_revision = PICO_SDK_VERSION_REVISION;
        \\
    );

    const mod = b.createModule(.{
        .target = target,
        .optimize = optimize,
        .link_libc = false,
    });

    const lib = b.addLibrary(.{
        .linkage = .static,
        .name = "pico_sdk",
        .root_module = mod,
    });

    // Add generated include path first
    lib.addIncludePath(generated);

    // Add stub source
    lib.addCSourceFile(.{
        .file = stub_source,
        .flags = &.{},
    });

    // Add compile definitions
    addCompileDefinitions(lib, chip, board);

    return lib;
}

fn addIncludePaths(lib: *std.Build.Step.Compile, chip: Chip) void {
    const b = lib.step.owner;

    // Common include paths
    lib.addSystemIncludePath(b.path("src/common/pico_base_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_binary_info/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_bit_ops_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_divider_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_sync/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_time/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_util/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_stdlib_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/pico_usb_reset_interface_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/hardware_claim/include"));
    lib.addSystemIncludePath(b.path("src/common/boot_picobin_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/boot_picoboot_headers/include"));
    lib.addSystemIncludePath(b.path("src/common/boot_uf2_headers/include"));

    // Boards
    lib.addSystemIncludePath(b.path("src/boards/include"));

    // Chip-specific include paths
    switch (chip) {
        .rp2040 => {
            lib.addSystemIncludePath(b.path("src/rp2040/hardware_regs/include"));
            lib.addSystemIncludePath(b.path("src/rp2040/hardware_structs/include"));
            lib.addSystemIncludePath(b.path("src/rp2040/pico_platform/include"));
            lib.addSystemIncludePath(b.path("src/rp2040/boot_stage2/include"));
            lib.addSystemIncludePath(b.path("src/rp2_common/cmsis/stub/CMSIS/Device/RP2040/Include"));
        },
        .rp2350 => {
            lib.addSystemIncludePath(b.path("src/rp2350/hardware_regs/include"));
            lib.addSystemIncludePath(b.path("src/rp2350/hardware_structs/include"));
            lib.addSystemIncludePath(b.path("src/rp2350/pico_platform/include"));
            lib.addSystemIncludePath(b.path("src/rp2350/boot_stage2/include"));
            lib.addSystemIncludePath(b.path("src/rp2_common/cmsis/stub/CMSIS/Device/RP2350/Include"));
        },
    }

    // RP2 common include paths
    const rp2_common_include_dirs = [_][]const u8{
        "src/rp2_common/boot_bootrom_headers/include",
        "src/rp2_common/cmsis/include",
        "src/rp2_common/cmsis/stub/CMSIS/Core/Include",
        "src/rp2_common/hardware_adc/include",
        "src/rp2_common/hardware_base/include",
        "src/rp2_common/hardware_boot_lock/include",
        "src/rp2_common/hardware_clocks/include",
        "src/rp2_common/hardware_dcp/include",
        "src/rp2_common/hardware_divider/include",
        "src/rp2_common/hardware_dma/include",
        "src/rp2_common/hardware_exception/include",
        "src/rp2_common/hardware_flash/include",
        "src/rp2_common/hardware_gpio/include",
        "src/rp2_common/hardware_hazard3/include",
        "src/rp2_common/hardware_i2c/include",
        "src/rp2_common/hardware_interp/include",
        "src/rp2_common/hardware_irq/include",
        "src/rp2_common/hardware_pio/include",
        "src/rp2_common/hardware_pll/include",
        "src/rp2_common/hardware_powman/include",
        "src/rp2_common/hardware_pwm/include",
        "src/rp2_common/hardware_rcp/include",
        "src/rp2_common/hardware_resets/include",
        "src/rp2_common/hardware_riscv/include",
        "src/rp2_common/hardware_riscv_platform_timer/include",
        "src/rp2_common/hardware_rtc/include",
        "src/rp2_common/hardware_sha256/include",
        "src/rp2_common/hardware_spi/include",
        "src/rp2_common/hardware_sync/include",
        "src/rp2_common/hardware_sync_spin_lock/include",
        "src/rp2_common/hardware_ticks/include",
        "src/rp2_common/hardware_timer/include",
        "src/rp2_common/hardware_uart/include",
        "src/rp2_common/hardware_vreg/include",
        "src/rp2_common/hardware_watchdog/include",
        "src/rp2_common/hardware_xip_cache/include",
        "src/rp2_common/hardware_xosc/include",
        "src/rp2_common/pico_aon_timer/include",
        "src/rp2_common/pico_async_context/include",
        "src/rp2_common/pico_atomic/include",
        "src/rp2_common/pico_bit_ops/include",
        "src/rp2_common/pico_bootrom/include",
        "src/rp2_common/pico_bootsel_via_double_reset/include",
        "src/rp2_common/pico_clib_interface/include",
        "src/rp2_common/pico_crt0/include",
        "src/rp2_common/pico_cxx_options/include",
        "src/rp2_common/pico_divider/include",
        "src/rp2_common/pico_double/include",
        "src/rp2_common/pico_fix/rp2040_usb_device_enumeration/include",
        "src/rp2_common/pico_flash/include",
        "src/rp2_common/pico_float/include",
        "src/rp2_common/pico_i2c_slave/include",
        "src/rp2_common/pico_int64_ops/include",
        "src/rp2_common/pico_malloc/include",
        "src/rp2_common/pico_mem_ops/include",
        "src/rp2_common/pico_multicore/include",
        "src/rp2_common/pico_platform_common/include",
        "src/rp2_common/pico_platform_compiler/include",
        "src/rp2_common/pico_platform_panic/include",
        "src/rp2_common/pico_platform_sections/include",
        "src/rp2_common/pico_printf/include",
        "src/rp2_common/pico_rand/include",
        "src/rp2_common/pico_runtime/include",
        "src/rp2_common/pico_runtime_init/include",
        "src/rp2_common/pico_sha256/include",
        "src/rp2_common/pico_standard_binary_info/include",
        "src/rp2_common/pico_standard_link/include",
        "src/rp2_common/pico_status_led/include",
        "src/rp2_common/pico_stdio/include",
        "src/rp2_common/pico_stdio_semihosting/include",
        "src/rp2_common/pico_stdio_uart/include",
        "src/rp2_common/pico_stdio_usb/include",
        "src/rp2_common/pico_stdlib/include",
        "src/rp2_common/pico_time_adapter/include",
        "src/rp2_common/pico_unique_id/include",
    };

    for (rp2_common_include_dirs) |dir| {
        lib.addSystemIncludePath(b.path(dir));
    }
}

fn addCompileDefinitions(lib: *std.Build.Step.Compile, chip: Chip, board: []const u8) void {
    lib.root_module.addCMacro("PICO_BUILD", "1");
    lib.root_module.addCMacro("PICO_ON_DEVICE", "1");
    lib.root_module.addCMacro("PICO_NO_HARDWARE", "0");
    lib.root_module.addCMacro("PICO_32BIT", "1");

    // Board definition
    lib.root_module.addCMacro("PICO_BOARD", board);

    switch (chip) {
        .rp2040 => {
            lib.root_module.addCMacro("PICO_RP2040", "1");
            lib.root_module.addCMacro("PICO_RP2350", "0");
        },
        .rp2350 => {
            lib.root_module.addCMacro("PICO_RP2040", "0");
            lib.root_module.addCMacro("PICO_RP2350", "1");
        },
    }

    // SDK version
    lib.root_module.addCMacro("PICO_SDK_VERSION_MAJOR", "2");
    lib.root_module.addCMacro("PICO_SDK_VERSION_MINOR", "2");
    lib.root_module.addCMacro("PICO_SDK_VERSION_REVISION", "0");
    lib.root_module.addCMacro("PICO_SDK_VERSION_STRING", "\"2.2.0\"");
}

// ============================================================================
// Public API for downstream projects
// ============================================================================

/// Returns the appropriate target for a given chip and CPU architecture
pub fn getTarget(chip: Chip, cpu_arch: CpuArch) std.Target.Query {
    return switch (chip) {
        .rp2040 => .{
            .cpu_arch = .thumb,
            .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
            .os_tag = .freestanding,
            .abi = .eabi,
        },
        .rp2350 => switch (cpu_arch) {
            .arm => .{
                .cpu_arch = .thumb,
                .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m33 },
                .os_tag = .freestanding,
                .abi = .eabi,
            },
            .riscv => .{
                .cpu_arch = .riscv32,
                .cpu_model = .{ .explicit = &std.Target.riscv.cpu.generic_rv32 },
                .os_tag = .freestanding,
                .abi = .eabi,
            },
        },
    };
}

/// Sets the linker script for proper Pico memory layout.
/// This is required for the binary to run on actual hardware.
/// flash_size_bytes: Optional flash size in bytes. Defaults to 2MB for RP2040, 4MB for RP2350.
pub fn setLinkerScript(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    flash_size_bytes: ?usize,
) void {
    const b = compile.step.owner;

    // Default flash sizes per chip (same as CMake/Bazel)
    const default_flash_size: usize = switch (chip) {
        .rp2040 => 2 * 1024 * 1024, // 2MB
        .rp2350 => 4 * 1024 * 1024, // 4MB
    };
    const flash_size = flash_size_bytes orelse default_flash_size;

    // SDK's linker script path
    const sdk_linker_script = switch (chip) {
        .rp2040 => sdk_dep.path("src/rp2_common/pico_crt0/rp2040/memmap_default.ld"),
        .rp2350 => sdk_dep.path("src/rp2_common/pico_crt0/rp2350/memmap_default.ld"),
    };

    // Use custom step to replace INCLUDE directive with actual flash region
    // Pass empty symbol_aliases for basic linker script without wrapping
    const empty_aliases: []const SymbolAlias = &.{};
    const transform_step = LinkerScriptTransform.create(b, sdk_linker_script, flash_size, empty_aliases);
    compile.setLinkerScript(transform_step.getOutput());
}

/// Sets the linker script with symbol wrapping support.
/// This enables pico_stdio, pico_printf, pico_float, etc. to intercept standard library calls.
/// Use this instead of setLinkerScript when you need wrapping functionality.
///
/// wrapped_components: Components that need their symbols wrapped (e.g., .pico_stdio, .pico_printf)
///
/// Note: pico_malloc wrapping is not supported as it requires an actual malloc implementation.
/// For malloc, either use Zig's allocator or link against a libc that provides malloc.
pub fn setLinkerScriptWithWrapping(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    flash_size_bytes: ?usize,
    wrapped_components: []const Component,
) void {
    const b = compile.step.owner;

    const default_flash_size: usize = switch (chip) {
        .rp2040 => 2 * 1024 * 1024,
        .rp2350 => 4 * 1024 * 1024,
    };
    const flash_size = flash_size_bytes orelse default_flash_size;

    const sdk_linker_script = switch (chip) {
        .rp2040 => sdk_dep.path("src/rp2_common/pico_crt0/rp2040/memmap_default.ld"),
        .rp2350 => sdk_dep.path("src/rp2_common/pico_crt0/rp2350/memmap_default.ld"),
    };

    // Collect all symbol aliases
    var symbol_aliases = std.ArrayList(SymbolAlias).initCapacity(b.allocator, 64) catch @panic("OOM");
    for (wrapped_components) |component| {
        const aliases = getComponentSymbolAliases(component);
        for (aliases) |alias| {
            symbol_aliases.append(b.allocator, alias) catch @panic("OOM");
        }
    }

    const transform_step = LinkerScriptTransform.create(
        b,
        sdk_linker_script,
        flash_size,
        symbol_aliases.toOwnedSlice(b.allocator) catch @panic("OOM"),
    );
    compile.setLinkerScript(transform_step.getOutput());
}

/// Represents a linker symbol alias: public_name = target_name
const SymbolAlias = struct {
    /// The public symbol name (e.g., "printf")
    name: []const u8,
    /// The target symbol to alias to (e.g., "stdio_printf" or "__wrap_printf")
    target: []const u8,
};

/// Custom build step that transforms a linker script by:
/// 1. Replacing the INCLUDE "pico_flash_region.ld" directive with actual flash region
/// 2. Adding symbol aliases for wrapped functions (e.g., printf = stdio_printf)
const LinkerScriptTransform = struct {
    step: std.Build.Step,
    input: std.Build.LazyPath,
    output: std.Build.GeneratedFile,
    flash_size: usize,
    symbol_aliases: []const SymbolAlias,

    fn create(
        b: *std.Build,
        input: std.Build.LazyPath,
        flash_size: usize,
        symbol_aliases: []const SymbolAlias,
    ) *LinkerScriptTransform {
        const self = b.allocator.create(LinkerScriptTransform) catch @panic("OOM");
        self.* = .{
            .step = std.Build.Step.init(.{
                .id = .custom,
                .name = "transform linker script",
                .owner = b,
                .makeFn = make,
            }),
            .input = input,
            .output = .{ .step = &self.step },
            .flash_size = flash_size,
            .symbol_aliases = symbol_aliases,
        };
        input.addStepDependencies(&self.step);
        return self;
    }

    fn getOutput(self: *LinkerScriptTransform) std.Build.LazyPath {
        return .{ .generated = .{ .file = &self.output } };
    }

    fn make(step: *std.Build.Step, _: std.Build.Step.MakeOptions) anyerror!void {
        const self: *LinkerScriptTransform = @fieldParentPtr("step", step);
        const b = step.owner;

        // Read the input linker script
        const input_path = self.input.getPath2(b, step);
        const content = std.fs.cwd().readFileAlloc(b.allocator, input_path, 64 * 1024) catch |err| {
            return step.fail("failed to read linker script '{s}': {s}", .{ input_path, @errorName(err) });
        };

        // Generate the flash region line
        const flash_region = b.fmt("    FLASH(rx) : ORIGIN = 0x10000000, LENGTH = {d}\n", .{self.flash_size});

        // Replace the INCLUDE line with the flash region
        var result = std.ArrayList(u8).initCapacity(b.allocator, content.len + 4096) catch @panic("OOM");
        var lines = std.mem.splitScalar(u8, content, '\n');
        while (lines.next()) |line| {
            if (std.mem.indexOf(u8, line, "INCLUDE") != null and
                std.mem.indexOf(u8, line, "pico_flash_region.ld") != null)
            {
                result.appendSlice(b.allocator, flash_region) catch @panic("OOM");
            } else {
                result.appendSlice(b.allocator, line) catch @panic("OOM");
                result.append(b.allocator, '\n') catch @panic("OOM");
            }
        }

        // Add symbol aliases at the end of the linker script
        // These redirect calls from standard names to SDK implementations
        if (self.symbol_aliases.len > 0) {
            result.appendSlice(b.allocator,
                \\
                \\/* Symbol wrapping - redirect standard library calls to SDK implementations */
                \\
            ) catch @panic("OOM");

            for (self.symbol_aliases) |alias| {
                // name = target;
                const alias_line = b.fmt("{s} = {s};\n", .{ alias.name, alias.target });
                result.appendSlice(b.allocator, alias_line) catch @panic("OOM");
            }
        }

        // Write to cache
        const cache_path = b.cache_root.join(b.allocator, &.{"memmap.ld"}) catch @panic("OOM");
        const cache_dir = std.fs.path.dirname(cache_path) orelse ".";
        std.fs.cwd().makePath(cache_dir) catch {};
        std.fs.cwd().writeFile(.{ .sub_path = cache_path, .data = result.items }) catch |err| {
            return step.fail("failed to write linker script: {s}", .{@errorName(err)});
        };

        self.output.path = cache_path;
    }
};

/// Generate minimal headers for boot2 compilation.
/// Boot2 assembly includes pico/asm_helper.S which normally pulls in the full SDK header chain.
/// We generate minimal stubs to avoid the complex dependency chain.
fn generateBoot2Headers(b: *std.Build) std.Build.LazyPath {
    const wf = b.addWriteFiles();

    // Minimal pico.h that just provides what asm_helper.S needs
    _ = wf.add("pico.h",
        \\// Minimal pico.h for boot2 assembly
        \\#ifndef _PICO_H
        \\#define _PICO_H
        \\// Boot2 doesn't need the full pico.h content
        \\#endif
        \\
    );

    // Minimal asm_helper.S with just the macros needed for boot2
    _ = wf.add("pico/asm_helper.S",
        \\// Minimal asm_helper.S for boot2
        \\
        \\.macro pico_default_asm_setup
        \\.syntax unified
        \\.cpu cortex-m0plus
        \\.thumb
        \\.endm
        \\
        \\.macro regular_func x
        \\.global \x
        \\.type \x,%function
        \\.thumb_func
        \\\x:
        \\.endm
        \\
        \\.macro regular_func_with_section x
        \\.section .text.\x
        \\regular_func \x
        \\.endm
        \\
    );

    return wf.getDirectory();
}

/// Boot2 variants available for RP2040
pub const Boot2 = enum {
    boot2_w25q080, // Default for most Pico boards (W25Q16JV flash)
    boot2_generic_03h, // Generic 03h read command (slowest, most compatible)
    boot2_at25sf128a,
    boot2_is25lp080,
    boot2_w25x10cl,
};

/// Adds the boot2 second-stage bootloader for RP2040.
/// This is required for RP2040 to boot from flash.
/// Call this for RP2040 builds only - RP2350 does not need boot2.
pub fn addBoot2(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    boot2_variant: Boot2,
) void {
    const b = compile.step.owner;

    // Get the boot2 source file
    const boot2_source = switch (boot2_variant) {
        .boot2_w25q080 => "src/rp2040/boot_stage2/boot2_w25q080.S",
        .boot2_generic_03h => "src/rp2040/boot_stage2/boot2_generic_03h.S",
        .boot2_at25sf128a => "src/rp2040/boot_stage2/boot2_at25sf128a.S",
        .boot2_is25lp080 => "src/rp2040/boot_stage2/boot2_is25lp080.S",
        .boot2_w25x10cl => "src/rp2040/boot_stage2/boot2_w25x10cl.S",
    };

    // Create an executable for boot2 with its special linker script
    const boot2_exe = b.addExecutable(.{
        .name = "boot2",
        .root_module = b.createModule(.{
            .target = b.resolveTargetQuery(.{
                .cpu_arch = .thumb,
                .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
                .os_tag = .freestanding,
                .abi = .eabi,
            }),
            .optimize = .ReleaseSmall,
        }),
    });

    // Add the boot2 assembly source
    boot2_exe.addAssemblyFile(sdk_dep.path(boot2_source));

    // Generate minimal headers for boot2 (avoids pulling in full SDK header chain)
    const boot2_headers = generateBoot2Headers(b);
    boot2_exe.addIncludePath(boot2_headers);

    // Add necessary include paths for the boot2 assembly
    boot2_exe.addSystemIncludePath(sdk_dep.path("src/rp2040/boot_stage2/asminclude"));
    boot2_exe.addSystemIncludePath(sdk_dep.path("src/rp2040/boot_stage2/include"));
    boot2_exe.addSystemIncludePath(sdk_dep.path("src/rp2040/hardware_regs/include"));

    // Use the boot_stage2 linker script
    boot2_exe.setLinkerScript(sdk_dep.path("src/rp2040/boot_stage2/boot_stage2.ld"));

    // Set the entry point
    boot2_exe.entry = .{ .symbol_name = "_stage2_boot" };

    // Create a custom step to pad and checksum the boot2 binary
    const boot2_transform = Boot2Transform.create(b, boot2_exe.getEmittedBin());

    // Add the generated checksummed boot2 assembly to the main compile
    compile.addAssemblyFile(boot2_transform.getOutput());
}

/// Custom build step that pads and checksums boot2 binary
const Boot2Transform = struct {
    step: std.Build.Step,
    input: std.Build.LazyPath,
    output: std.Build.GeneratedFile,

    fn create(b: *std.Build, input: std.Build.LazyPath) *Boot2Transform {
        const self = b.allocator.create(Boot2Transform) catch @panic("OOM");
        self.* = .{
            .step = std.Build.Step.init(.{
                .id = .custom,
                .name = "pad and checksum boot2",
                .owner = b,
                .makeFn = make,
            }),
            .input = input,
            .output = .{ .step = &self.step },
        };
        input.addStepDependencies(&self.step);
        return self;
    }

    fn getOutput(self: *Boot2Transform) std.Build.LazyPath {
        return .{ .generated = .{ .file = &self.output } };
    }

    fn make(step: *std.Build.Step, _: std.Build.Step.MakeOptions) anyerror!void {
        const self: *Boot2Transform = @fieldParentPtr("step", step);
        const b = step.owner;

        // Read the boot2 ELF binary
        const input_path = self.input.getPath2(b, step);

        // Read the .text section from the ELF
        // For simplicity, we'll read the raw binary output
        // The boot2 linker script places everything at a fixed address
        const elf_data = std.fs.cwd().readFileAlloc(b.allocator, input_path, 64 * 1024) catch |err| {
            return step.fail("failed to read boot2 binary '{s}': {s}", .{ input_path, @errorName(err) });
        };

        // Parse ELF to extract the loadable segment
        const binary_data = extractElfText(b.allocator, elf_data) catch |err| {
            return step.fail("failed to extract boot2 text: {s}", .{@errorName(err)});
        };

        if (binary_data.len > 252) {
            return step.fail("boot2 code too large: {d} bytes (max 252)", .{binary_data.len});
        }

        // Pad to 252 bytes
        var padded: [252]u8 = [_]u8{0} ** 252;
        @memcpy(padded[0..binary_data.len], binary_data);

        // Calculate CRC32 with bit reversal (matching pad_checksum script)
        const checksum = calculateBoot2Checksum(&padded);

        // Generate assembly output
        var output = std.ArrayList(u8).initCapacity(b.allocator, 4096) catch @panic("OOM");
        const writer = output.writer(b.allocator);

        try writer.writeAll("// Padded and checksummed boot2\n\n");
        try writer.writeAll(".cpu cortex-m0plus\n");
        try writer.writeAll(".thumb\n\n");
        try writer.writeAll(".section .boot2, \"ax\"\n\n");

        // Write bytes in groups of 16
        var i: usize = 0;
        while (i < 252) : (i += 16) {
            try writer.writeAll(".byte ");
            var j: usize = 0;
            while (j < 16 and i + j < 252) : (j += 1) {
                if (j > 0) try writer.writeAll(", ");
                try writer.print("0x{x:0>2}", .{padded[i + j]});
            }
            try writer.writeAll("\n");
        }

        // Write the 4-byte checksum
        try writer.print(".byte 0x{x:0>2}, 0x{x:0>2}, 0x{x:0>2}, 0x{x:0>2}\n", .{
            @as(u8, @truncate(checksum)),
            @as(u8, @truncate(checksum >> 8)),
            @as(u8, @truncate(checksum >> 16)),
            @as(u8, @truncate(checksum >> 24)),
        });

        // Write to cache
        const cache_path = b.cache_root.join(b.allocator, &.{"boot2_checksummed.S"}) catch @panic("OOM");
        const cache_dir = std.fs.path.dirname(cache_path) orelse ".";
        std.fs.cwd().makePath(cache_dir) catch {};
        std.fs.cwd().writeFile(.{ .sub_path = cache_path, .data = output.items }) catch |err| {
            return step.fail("failed to write boot2 assembly: {s}", .{@errorName(err)});
        };

        self.output.path = cache_path;
    }

    fn extractElfText(allocator: std.mem.Allocator, elf_data: []const u8) ![]const u8 {
        // Parse ELF to extract the code at boot2 address (0x20041f00)
        if (elf_data.len < 52) return error.InvalidElf;
        if (!std.mem.eql(u8, elf_data[0..4], "\x7fELF")) return error.InvalidElf;

        // 32-bit ELF header fields
        const e_phoff = std.mem.readInt(u32, elf_data[28..32], .little);
        const e_shoff = std.mem.readInt(u32, elf_data[32..36], .little);
        const e_phentsize = std.mem.readInt(u16, elf_data[42..44], .little);
        const e_phnum = std.mem.readInt(u16, elf_data[44..46], .little);
        const e_shentsize = std.mem.readInt(u16, elf_data[46..48], .little);
        const e_shnum = std.mem.readInt(u16, elf_data[48..50], .little);

        // Boot2 is loaded at 0x20041f00
        const boot2_addr: u32 = 0x20041f00;

        // First try: Find PT_LOAD segment at boot2 address
        var i: usize = 0;
        while (i < e_phnum) : (i += 1) {
            const ph_offset = e_phoff + i * e_phentsize;
            if (ph_offset + 32 > elf_data.len) continue;

            const p_type = std.mem.readInt(u32, elf_data[ph_offset..][0..4], .little);
            if (p_type == 1) { // PT_LOAD
                const p_offset = std.mem.readInt(u32, elf_data[ph_offset + 4 ..][0..4], .little);
                const p_vaddr = std.mem.readInt(u32, elf_data[ph_offset + 8 ..][0..4], .little);
                const p_filesz = std.mem.readInt(u32, elf_data[ph_offset + 16 ..][0..4], .little);

                // Check if this segment is at or contains the boot2 address
                if (p_vaddr == boot2_addr or (p_vaddr <= boot2_addr and p_vaddr + p_filesz > boot2_addr)) {
                    if (p_offset + p_filesz > elf_data.len) return error.InvalidElf;
                    const result = allocator.alloc(u8, p_filesz) catch return error.OutOfMemory;
                    @memcpy(result, elf_data[p_offset..][0..p_filesz]);
                    return result;
                }
            }
        }

        // Fallback: Look for .text section
        if (e_shoff > 0 and e_shnum > 0) {
            // Get section header string table index
            const e_shstrndx = std.mem.readInt(u16, elf_data[50..52], .little);
            if (e_shstrndx < e_shnum) {
                const shstrtab_off = e_shoff + e_shstrndx * e_shentsize;
                if (shstrtab_off + 40 <= elf_data.len) {
                    const shstrtab_offset = std.mem.readInt(u32, elf_data[shstrtab_off + 16 ..][0..4], .little);

                    // Iterate sections looking for .text
                    var s: usize = 0;
                    while (s < e_shnum) : (s += 1) {
                        const sh_offset = e_shoff + s * e_shentsize;
                        if (sh_offset + 40 > elf_data.len) continue;

                        const sh_name_off = std.mem.readInt(u32, elf_data[sh_offset..][0..4], .little);
                        const sh_type = std.mem.readInt(u32, elf_data[sh_offset + 4 ..][0..4], .little);
                        const sh_off = std.mem.readInt(u32, elf_data[sh_offset + 16 ..][0..4], .little);
                        const sh_size = std.mem.readInt(u32, elf_data[sh_offset + 20 ..][0..4], .little);

                        // SHT_PROGBITS = 1
                        if (sh_type == 1 and sh_size > 0) {
                            const name_start = shstrtab_offset + sh_name_off;
                            if (name_start + 5 <= elf_data.len) {
                                if (std.mem.eql(u8, elf_data[name_start..][0..5], ".text")) {
                                    if (sh_off + sh_size <= elf_data.len) {
                                        const result = allocator.alloc(u8, sh_size) catch return error.OutOfMemory;
                                        @memcpy(result, elf_data[sh_off..][0..sh_size]);
                                        return result;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return error.NoLoadSegment;
    }

    fn calculateBoot2Checksum(data: *const [252]u8) u32 {
        // CRC32 with bit reversal, matching the pad_checksum Python script
        // The bootrom uses a slightly unusual CRC32 variant

        // Bit reverse a byte
        const bitrev8 = struct {
            fn f(x: u8) u8 {
                var result: u8 = 0;
                var val = x;
                var i: u3 = 0;
                while (true) {
                    result = (result << 1) | (val & 1);
                    val >>= 1;
                    if (i == 7) break;
                    i += 1;
                }
                return result;
            }
        }.f;

        // Bit reverse a 32-bit value
        const bitrev32 = struct {
            fn f(x: u32) u32 {
                var result: u32 = 0;
                var val = x;
                var i: u5 = 0;
                while (true) {
                    result = (result << 1) | (val & 1);
                    val >>= 1;
                    if (i == 31) break;
                    i += 1;
                }
                return result;
            }
        }.f;

        // Standard CRC32 polynomial (reflected)
        const polynomial: u32 = 0xEDB88320;

        // Calculate CRC32 on bit-reversed input bytes
        // The pad_checksum script does: bitrev32((crc32(bitrev_bytes, 0) ^ 0xffffffff))
        // Since crc32 already does final XOR, and then we XOR again, they cancel out.
        // So we compute CRC32 without the final XOR, then bit-reverse.
        var crc: u32 = 0xFFFFFFFF; // Standard CRC32 initial value
        for (data) |byte| {
            const rev_byte = bitrev8(byte);
            crc ^= @as(u32, rev_byte);
            for (0..8) |_| {
                if (crc & 1 != 0) {
                    crc = (crc >> 1) ^ polynomial;
                } else {
                    crc >>= 1;
                }
            }
        }

        // No final XOR - the two XORs in pad_checksum cancel out
        return bitrev32(crc);
    }
};

/// Adds all pico-sdk include paths and compile definitions to a compile step.
/// Call this from your project's build.zig to set up the SDK.
pub fn addTo(sdk_dep: *std.Build.Dependency, compile: *std.Build.Step.Compile, chip: Chip, board: []const u8) void {
    const b = compile.step.owner;

    // Generate config headers for this compile step
    const generated = generateConfigHeadersForDep(b, chip, board);
    compile.addIncludePath(generated);

    // Add libc stubs for freestanding builds (must come before SDK includes)
    compile.addSystemIncludePath(sdk_dep.path("zig/libc_stubs"));

    // Add all SDK include paths
    addSdkIncludePaths(sdk_dep, compile, chip);

    // Add compile definitions
    addSdkCompileDefinitions(compile, chip, board);
}

fn generateConfigHeadersForDep(b: *std.Build, chip: Chip, board: []const u8) std.Build.LazyPath {
    const wf = b.addWriteFiles();

    // Generate pico/version.h
    _ = wf.add("pico/version.h",
        \\/*
        \\ * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
        \\ *
        \\ * SPDX-License-Identifier: BSD-3-Clause
        \\ */
        \\
        \\// THIS FILE IS AUTOGENERATED; DO NOT EDIT
        \\
        \\#ifndef _PICO_VERSION_H
        \\#define _PICO_VERSION_H
        \\
        \\#define PICO_SDK_VERSION_MAJOR    2
        \\#define PICO_SDK_VERSION_MINOR    2
        \\#define PICO_SDK_VERSION_REVISION 0
        \\#define PICO_SDK_VERSION_STRING   "2.2.0"
        \\
        \\#endif
        \\
    );

    // Generate pico_config_extra_headers.h (empty by default)
    _ = wf.add("pico_config_extra_headers.h",
        \\// Extra headers - add custom includes here if needed
        \\
    );

    // Generate pico_config_platform_headers.h based on board and chip
    const platform_header = switch (chip) {
        .rp2040 => b.fmt(
            \\// Platform headers for RP2040
            \\#include "cmsis/rename_exceptions.h"
            \\#include "boards/{s}.h"
            \\
        , .{board}),
        .rp2350 => b.fmt(
            \\// Platform headers for RP2350
            \\#include "cmsis/rename_exceptions.h"
            \\#include "boards/{s}.h"
            \\
        , .{board}),
    };
    _ = wf.add("pico_config_platform_headers.h", platform_header);

    // Generate pico/config_autogen.h
    _ = wf.add("pico/config_autogen.h",
        \\// AUTOGENERATED - DO NOT EDIT
        \\//
        \\// This header includes platform and extra configuration headers.
        \\
        \\// Extra headers (custom user configuration)
        \\#include "pico_config_extra_headers.h"
        \\
        \\// Platform-specific headers (board and chip configuration)
        \\#include "pico_config_platform_headers.h"
        \\
    );

    return wf.getDirectory();
}

fn addSdkIncludePaths(sdk_dep: *std.Build.Dependency, compile: *std.Build.Step.Compile, chip: Chip) void {
    // Common include paths
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_base_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_binary_info/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_bit_ops_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_divider_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_sync/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_time/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_util/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_stdlib_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/pico_usb_reset_interface_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/hardware_claim/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/boot_picobin_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/boot_picoboot_headers/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/common/boot_uf2_headers/include"));

    // Boards
    compile.addSystemIncludePath(sdk_dep.path("src/boards/include"));

    // Chip-specific include paths
    switch (chip) {
        .rp2040 => {
            compile.addSystemIncludePath(sdk_dep.path("src/rp2040/hardware_regs/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2040/hardware_structs/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2040/pico_platform/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2040/boot_stage2/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2_common/cmsis/stub/CMSIS/Device/RP2040/Include"));
        },
        .rp2350 => {
            compile.addSystemIncludePath(sdk_dep.path("src/rp2350/hardware_regs/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2350/hardware_structs/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2350/pico_platform/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2350/boot_stage2/include"));
            compile.addSystemIncludePath(sdk_dep.path("src/rp2_common/cmsis/stub/CMSIS/Device/RP2350/Include"));
        },
    }

    // RP2 common include paths
    const rp2_common_dirs = [_][]const u8{
        "src/rp2_common/boot_bootrom_headers/include",
        "src/rp2_common/cmsis/include",
        "src/rp2_common/cmsis/stub/CMSIS/Core/Include",
        "src/rp2_common/hardware_adc/include",
        "src/rp2_common/hardware_base/include",
        "src/rp2_common/hardware_boot_lock/include",
        "src/rp2_common/hardware_clocks/include",
        "src/rp2_common/hardware_dcp/include",
        "src/rp2_common/hardware_divider/include",
        "src/rp2_common/hardware_dma/include",
        "src/rp2_common/hardware_exception/include",
        "src/rp2_common/hardware_flash/include",
        "src/rp2_common/hardware_gpio/include",
        "src/rp2_common/hardware_hazard3/include",
        "src/rp2_common/hardware_i2c/include",
        "src/rp2_common/hardware_interp/include",
        "src/rp2_common/hardware_irq/include",
        "src/rp2_common/hardware_pio/include",
        "src/rp2_common/hardware_pll/include",
        "src/rp2_common/hardware_powman/include",
        "src/rp2_common/hardware_pwm/include",
        "src/rp2_common/hardware_rcp/include",
        "src/rp2_common/hardware_resets/include",
        "src/rp2_common/hardware_riscv/include",
        "src/rp2_common/hardware_riscv_platform_timer/include",
        "src/rp2_common/hardware_rtc/include",
        "src/rp2_common/hardware_sha256/include",
        "src/rp2_common/hardware_spi/include",
        "src/rp2_common/hardware_sync/include",
        "src/rp2_common/hardware_sync_spin_lock/include",
        "src/rp2_common/hardware_ticks/include",
        "src/rp2_common/hardware_timer/include",
        "src/rp2_common/hardware_uart/include",
        "src/rp2_common/hardware_vreg/include",
        "src/rp2_common/hardware_watchdog/include",
        "src/rp2_common/hardware_xip_cache/include",
        "src/rp2_common/hardware_xosc/include",
        "src/rp2_common/pico_aon_timer/include",
        "src/rp2_common/pico_async_context/include",
        "src/rp2_common/pico_atomic/include",
        "src/rp2_common/pico_bit_ops/include",
        "src/rp2_common/pico_bootrom/include",
        "src/rp2_common/pico_clib_interface/include",
        "src/rp2_common/pico_crt0/include",
        "src/rp2_common/pico_divider/include",
        "src/rp2_common/pico_double/include",
        "src/rp2_common/pico_flash/include",
        "src/rp2_common/pico_float/include",
        "src/rp2_common/pico_i2c_slave/include",
        "src/rp2_common/pico_int64_ops/include",
        "src/rp2_common/pico_malloc/include",
        "src/rp2_common/pico_mem_ops/include",
        "src/rp2_common/pico_multicore/include",
        "src/rp2_common/pico_platform_common/include",
        "src/rp2_common/pico_platform_compiler/include",
        "src/rp2_common/pico_platform_panic/include",
        "src/rp2_common/pico_platform_sections/include",
        "src/rp2_common/pico_printf/include",
        "src/rp2_common/pico_rand/include",
        "src/rp2_common/pico_runtime/include",
        "src/rp2_common/pico_runtime_init/include",
        "src/rp2_common/pico_sha256/include",
        "src/rp2_common/pico_standard_binary_info/include",
        "src/rp2_common/pico_standard_link/include",
        "src/rp2_common/pico_stdio/include",
        "src/rp2_common/pico_stdio_semihosting/include",
        "src/rp2_common/pico_stdio_uart/include",
        "src/rp2_common/pico_stdio_usb/include",
        "src/rp2_common/pico_stdlib/include",
        "src/rp2_common/pico_time_adapter/include",
        "src/rp2_common/pico_unique_id/include",
    };

    for (rp2_common_dirs) |dir| {
        compile.addSystemIncludePath(sdk_dep.path(dir));
    }

    // TinyUSB includes (for USB support)
    compile.addSystemIncludePath(sdk_dep.path("lib/tinyusb/src"));
    compile.addSystemIncludePath(sdk_dep.path("src/rp2_common/tinyusb/include"));
    compile.addSystemIncludePath(sdk_dep.path("src/rp2_common/pico_fix/rp2040_usb_device_enumeration/include"));
}

fn addSdkCompileDefinitions(compile: *std.Build.Step.Compile, chip: Chip, board: []const u8) void {
    compile.root_module.addCMacro("PICO_BUILD", "1");
    compile.root_module.addCMacro("PICO_ON_DEVICE", "1");
    compile.root_module.addCMacro("PICO_NO_HARDWARE", "0");
    compile.root_module.addCMacro("PICO_32BIT", "1");
    compile.root_module.addCMacro("PICO_BOARD", board);

    switch (chip) {
        .rp2040 => {
            compile.root_module.addCMacro("PICO_RP2040", "1");
            compile.root_module.addCMacro("PICO_RP2350", "0");
        },
        .rp2350 => {
            compile.root_module.addCMacro("PICO_RP2040", "0");
            compile.root_module.addCMacro("PICO_RP2350", "1");
        },
    }

    compile.root_module.addCMacro("PICO_SDK_VERSION_MAJOR", "2");
    compile.root_module.addCMacro("PICO_SDK_VERSION_MINOR", "2");
    compile.root_module.addCMacro("PICO_SDK_VERSION_REVISION", "0");
    compile.root_module.addCMacro("PICO_SDK_VERSION_STRING", "\"2.2.0\"");
}

/// Add SDK C source files to a compile step
/// This allows you to selectively include SDK sources you need
pub fn addCSourceFiles(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    sources: []const []const u8,
) void {
    for (sources) |src| {
        compile.addCSourceFile(.{
            .file = sdk_dep.path(src),
            .flags = sdk_c_flags,
        });
    }
}

const sdk_c_flags: []const []const u8 = &.{
    "-std=gnu11",
    "-ffunction-sections",
    "-fdata-sections",
    "-fno-strict-aliasing",
    "-ffreestanding",
    "-D__always_inline=__attribute__((__always_inline__)) inline",
    "-D__printflike(a,b)=__attribute__((__format__(__printf__,a,b)))",
    "-Dstatic_assert=_Static_assert",
};

/// SDK components that can be added to a project
pub const Component = enum {
    // Hardware peripherals
    hardware_gpio,
    hardware_clocks,
    hardware_pll,
    hardware_xosc,
    hardware_watchdog,
    hardware_irq,
    hardware_sync,
    hardware_timer,
    hardware_ticks,
    hardware_uart,
    hardware_spi,
    hardware_i2c,
    hardware_pwm,
    hardware_adc,
    hardware_dma,
    hardware_pio,
    hardware_flash,
    hardware_divider,
    hardware_interp,
    hardware_exception,
    hardware_resets,
    hardware_rtc,
    hardware_vreg,
    hardware_xip_cache,

    // Platform and runtime
    pico_platform,
    pico_runtime,
    pico_runtime_init,
    pico_crt0,
    pico_time,
    pico_clib_minimal,

    // Standard I/O
    pico_stdio,
    pico_stdio_uart,
    pico_stdio_semihosting,

    // Multicore
    pico_multicore,

    // Phase 2: Math and utility libraries
    pico_printf,
    pico_malloc,
    pico_float,
    pico_double,
    pico_divider,
    pico_int64_ops,
    pico_bit_ops,
    pico_mem_ops,
    pico_rand,
    pico_unique_id,
    pico_bootrom,
    pico_atomic,
    pico_sync,
    pico_stdlib,

    // Phase 3: RP2350-specific components
    hardware_sha256,
    hardware_powman,
    hardware_boot_lock,
    pico_sha256,

    // Phase 5: Async context and additional utilities
    pico_async_context_base,
    pico_async_context_poll,
    pico_async_context_threadsafe_background,
    pico_flash,
    pico_i2c_slave,
    pico_aon_timer,
    hardware_sync_spin_lock,

    // Phase 4: USB support
    pico_stdio_usb,
    pico_fix_rp2040_usb_device_enumeration,
};

/// Add SDK components to a compile step. This is the recommended way to use the SDK.
/// Components automatically include their dependencies.
pub fn addComponent(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    cpu_arch: CpuArch,
    component: Component,
) void {
    const sources = getComponentSources(chip, cpu_arch, component);
    for (sources) |src| {
        if (std.mem.endsWith(u8, src, ".S")) {
            compile.addAssemblyFile(sdk_dep.path(src));
        } else {
            compile.addCSourceFile(.{
                .file = sdk_dep.path(src),
                .flags = sdk_c_flags,
            });
        }
    }
}

/// Add multiple SDK components at once
pub fn addComponents(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    cpu_arch: CpuArch,
    components: []const Component,
) void {
    for (components) |component| {
        addComponent(sdk_dep, compile, chip, cpu_arch, component);
    }
}

/// Convenience version of addComponent that defaults to ARM architecture
pub fn addComponentArm(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    component: Component,
) void {
    addComponent(sdk_dep, compile, chip, .arm, component);
}

/// Convenience version of addComponents that defaults to ARM architecture
pub fn addComponentsArm(
    sdk_dep: *std.Build.Dependency,
    compile: *std.Build.Step.Compile,
    chip: Chip,
    components: []const Component,
) void {
    addComponents(sdk_dep, compile, chip, .arm, components);
}

/// Get the list of functions that need linker wrapping for a component.
/// Some SDK components require wrapping standard library functions via --wrap=<func>.
/// Returns a slice of function names that should be wrapped.
///
/// Note: Zig's build system doesn't expose a direct API to add arbitrary linker flags.
/// To use components that require wrapping (pico_stdio, pico_printf, pico_malloc, pico_float, pico_double),
/// you may need to either:
/// 1. Not use those components and let the compiler provide default implementations
/// 2. Use a custom linker script that defines the wrapped symbols
/// 3. Build with CMake/Bazel for full wrapping support
pub fn getLinkerWrapSymbols(chip: Chip, component: Component) []const []const u8 {
    return getComponentWrapFlags(chip, component);
}

/// Check if a component requires linker wrapping to function properly
pub fn componentRequiresWrapping(component: Component) bool {
    return switch (component) {
        .pico_stdio, .pico_printf, .pico_malloc, .pico_divider, .pico_bit_ops, .pico_mem_ops, .pico_int64_ops, .pico_float, .pico_double => true,
        else => false,
    };
}

/// TinyUSB configuration for USB support
pub const TinyUSBMode = enum {
    device,
    host,
    dual,
};

/// Add TinyUSB library for USB support.
/// Returns a static library that should be linked to your executable.
/// The library is built with pico-sdk headers and OSAL support.
///
/// Example usage:
/// ```zig
/// const tinyusb_lib = pico_sdk.addTinyUSB(sdk_dep, .{
///     .target = target,
///     .optimize = optimize,
///     .chip = chip,
///     .mode = .device,
/// });
/// // Add tusb_config.h include path to TinyUSB
/// tinyusb_lib.addIncludePath(b.path("src"));
/// exe.linkLibrary(tinyusb_lib);
/// ```
pub fn addTinyUSB(
    sdk_dep: *std.Build.Dependency,
    options: struct {
        target: std.Build.ResolvedTarget,
        optimize: std.builtin.OptimizeMode,
        chip: Chip,
        board: []const u8 = "pico",
        mode: TinyUSBMode = .device,
        cdc: bool = true,
        hid: bool = false,
        msc: bool = false,
        midi: bool = false,
        vendor: bool = true, // Needed for reset interface
    },
) *std.Build.Step.Compile {
    const b = sdk_dep.builder;

    const mod = b.createModule(.{
        .target = options.target,
        .optimize = options.optimize,
        .link_libc = false,
    });

    const lib = b.addLibrary(.{
        .linkage = .static,
        .name = "tinyusb",
        .root_module = mod,
    });

    // TinyUSB source path within pico-sdk
    const tinyusb_src = sdk_dep.path("lib/tinyusb/src");

    // Define the MCU - both RP2040 and RP2350 use the same USB controller
    lib.root_module.addCMacro("CFG_TUSB_MCU", "OPT_MCU_RP2040");
    lib.root_module.addCMacro("CFG_TUSB_OS", "OPT_OS_PICO");

    const c_flags: []const []const u8 = &.{
        "-Wno-unused-parameter",
        "-Wno-cast-function-type",
        "-Wno-sign-compare",
        "-fno-sanitize=undefined",
    };

    // Common sources (always needed)
    lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "tusb.c"), .flags = c_flags });
    lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "common/tusb_fifo.c"), .flags = c_flags });

    // Device mode sources
    if (options.mode == .device or options.mode == .dual) {
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "device/usbd.c"), .flags = c_flags });
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "device/usbd_control.c"), .flags = c_flags });
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "portable/raspberrypi/rp2040/dcd_rp2040.c"), .flags = c_flags });
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "portable/raspberrypi/rp2040/rp2040_usb.c"), .flags = c_flags });

        // Device class drivers
        if (options.cdc) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/cdc/cdc_device.c"), .flags = c_flags });
        if (options.hid) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/hid/hid_device.c"), .flags = c_flags });
        if (options.msc) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/msc/msc_device.c"), .flags = c_flags });
        if (options.midi) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/midi/midi_device.c"), .flags = c_flags });
        if (options.vendor) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/vendor/vendor_device.c"), .flags = c_flags });
    }

    // Host mode sources
    if (options.mode == .host or options.mode == .dual) {
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "host/usbh.c"), .flags = c_flags });
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "host/hub.c"), .flags = c_flags });
        lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "portable/raspberrypi/rp2040/hcd_rp2040.c"), .flags = c_flags });
        if (options.mode == .host) {
            lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "portable/raspberrypi/rp2040/rp2040_usb.c"), .flags = c_flags });
        }

        // Host class drivers
        if (options.cdc) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/cdc/cdc_host.c"), .flags = c_flags });
        if (options.hid) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/hid/hid_host.c"), .flags = c_flags });
        if (options.msc) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/msc/msc_host.c"), .flags = c_flags });
        if (options.vendor) lib.addCSourceFile(.{ .file = tinyusb_src.path(b, "class/vendor/vendor_host.c"), .flags = c_flags });
    }

    // Add libc stubs first (for freestanding builds)
    lib.addSystemIncludePath(sdk_dep.path("zig/libc_stubs"));

    // Add pico-sdk include paths (includes TinyUSB path)
    addSdkIncludePaths(sdk_dep, lib, options.chip);

    // Add generated config headers
    const generated = generateConfigHeadersForDep(b, options.chip, options.board);
    lib.addIncludePath(generated);

    // Add SDK compile definitions
    addSdkCompileDefinitions(lib, options.chip, options.board);

    return lib;
}

/// Add compile definitions required for wrapped components to work correctly.
/// Call this on your compile step when using setLinkerScriptWithWrapping.
///
/// This sets up defines like LIB_PICO_PRINTF_PICO so that pico_stdio uses the SDK's
/// printf implementation instead of trying to call through to __real_vprintf.
pub fn addWrappingDefinitions(compile: *std.Build.Step.Compile, components: []const Component) void {
    for (components) |component| {
        switch (component) {
            .pico_printf => {
                // Tell pico_stdio to use SDK's printf (vfctprintf) instead of __real_vprintf
                compile.root_module.addCMacro("LIB_PICO_PRINTF_PICO", "1");
            },
            .pico_stdio => {
                // Disable short-circuit mode because it uses __attribute__((alias(...)))
                // which doesn't work with Zig's C compiler. Instead, we use linker script
                // aliases to redirect printf/etc. to stdio_* functions directly.
                compile.root_module.addCMacro("PICO_STDIO_SHORT_CIRCUIT_CLIB_FUNCS", "0");
            },
            else => {},
        }
    }
}

/// Get symbol aliases for a component.
/// For pico_stdio, aliases point directly to stdio_* functions to avoid
/// the __wrap_*/__real_* indirection that requires --wrap linker flags.
/// For other components, aliases point to __wrap_* functions.
fn getComponentSymbolAliases(component: Component) []const SymbolAlias {
    return switch (component) {
        // pico_stdio: alias directly to stdio_* implementations
        // This avoids the __attribute__((alias(...))) issue with PICO_STDIO_SHORT_CIRCUIT_CLIB_FUNCS
        // Also provide __real_* aliases for the __wrap_* functions that call them
        .pico_stdio => &.{
            // Public API aliases
            .{ .name = "printf", .target = "stdio_printf" },
            .{ .name = "vprintf", .target = "stdio_vprintf" },
            .{ .name = "puts", .target = "stdio_puts" },
            .{ .name = "putchar", .target = "stdio_putchar" },
            .{ .name = "getchar", .target = "stdio_getchar" },
            // __real_* aliases for the __wrap_* wrapper functions
            .{ .name = "__real_printf", .target = "stdio_printf" },
            .{ .name = "__real_vprintf", .target = "stdio_vprintf" },
            .{ .name = "__real_puts", .target = "stdio_puts" },
            .{ .name = "__real_putchar", .target = "stdio_putchar" },
            .{ .name = "__real_getchar", .target = "stdio_getchar" },
        },
        // pico_printf: alias to __wrap_* functions
        .pico_printf => &.{
            .{ .name = "sprintf", .target = "__wrap_sprintf" },
            .{ .name = "snprintf", .target = "__wrap_snprintf" },
            .{ .name = "vsnprintf", .target = "__wrap_vsnprintf" },
        },
        // pico_malloc: not supported (requires actual allocator implementation)
        .pico_malloc => &.{},
        // Most other components: TODO - add as needed
        else => &.{},
    };
}

/// Legacy function for compatibility - returns symbol names that need wrapping.
/// Use getComponentSymbolAliases for linker script generation.
fn getComponentWrapFlags(chip: Chip, component: Component) []const []const u8 {
    return switch (component) {
        .pico_stdio => &.{
            "printf",
            "vprintf",
            "puts",
            "putchar",
            "getchar",
        },
        .pico_printf => &.{
            "sprintf",
            "snprintf",
            "vsnprintf",
        },
        .pico_malloc => &.{
            "malloc",
            "calloc",
            "realloc",
            "free",
        },
        .pico_divider => switch (chip) {
            .rp2040 => &.{
                "__aeabi_idiv",
                "__aeabi_idivmod",
                "__aeabi_ldivmod",
                "__aeabi_uidiv",
                "__aeabi_uidivmod",
                "__aeabi_uldivmod",
            },
            .rp2350 => &.{}, // RP2350 uses compiler implementation
        },
        .pico_bit_ops => switch (chip) {
            .rp2040 => &.{
                "__clzsi2",
                "__clzdi2",
                "__ctzsi2",
                "__ctzdi2",
                "__popcountsi2",
                "__popcountdi2",
                "__clz",
                "__clzl",
                "__clzll",
            },
            .rp2350 => &.{
                "__ctzdi2", // Only this one is wrapped on RP2350
            },
        },
        .pico_mem_ops => switch (chip) {
            .rp2040 => &.{
                "memcpy",
                "memset",
                "__aeabi_memcpy",
                "__aeabi_memset",
                "__aeabi_memcpy4",
                "__aeabi_memset4",
                "__aeabi_memcpy8",
                "__aeabi_memset8",
            },
            .rp2350 => &.{}, // RP2350 uses compiler implementation
        },
        .pico_int64_ops => switch (chip) {
            .rp2040 => &.{
                "__aeabi_lmul",
            },
            .rp2350 => &.{},
        },
        .pico_float => &.{
            // AEABI arithmetic
            "__aeabi_fadd",
            "__aeabi_fdiv",
            "__aeabi_fmul",
            "__aeabi_frsub",
            "__aeabi_fsub",
            // AEABI compare
            "__aeabi_cfcmpeq",
            "__aeabi_cfrcmple",
            "__aeabi_cfcmple",
            "__aeabi_fcmpeq",
            "__aeabi_fcmplt",
            "__aeabi_fcmple",
            "__aeabi_fcmpge",
            "__aeabi_fcmpgt",
            "__aeabi_fcmpun",
            // AEABI conversions
            "__aeabi_i2f",
            "__aeabi_ui2f",
            "__aeabi_f2iz",
            "__aeabi_f2uiz",
            "__aeabi_l2f",
            "__aeabi_ul2f",
            "__aeabi_f2lz",
            "__aeabi_f2ulz",
            "__aeabi_f2d",
            // Math functions
            "sqrtf",
            "cosf",
            "sinf",
            "tanf",
            "atan2f",
            "expf",
            "logf",
            "ldexpf",
            "copysignf",
            "truncf",
            "floorf",
            "ceilf",
            "roundf",
            "sincosf",
            "asinf",
            "acosf",
            "atanf",
            "sinhf",
            "coshf",
            "tanhf",
            "asinhf",
            "acoshf",
            "atanhf",
            "exp2f",
            "log2f",
            "exp10f",
            "log10f",
            "powf",
            "powintf",
            "hypotf",
            "cbrtf",
            "fmodf",
            "dremf",
            "remainderf",
            "remquof",
            "expm1f",
            "log1pf",
            "fmaf",
        },
        .pico_double => &.{
            // AEABI arithmetic
            "__aeabi_dadd",
            "__aeabi_ddiv",
            "__aeabi_dmul",
            "__aeabi_drsub",
            "__aeabi_dsub",
            // AEABI compare
            "__aeabi_cdcmpeq",
            "__aeabi_cdrcmple",
            "__aeabi_cdcmple",
            "__aeabi_dcmpeq",
            "__aeabi_dcmplt",
            "__aeabi_dcmple",
            "__aeabi_dcmpge",
            "__aeabi_dcmpgt",
            "__aeabi_dcmpun",
            // AEABI conversions
            "__aeabi_i2d",
            "__aeabi_l2d",
            "__aeabi_ui2d",
            "__aeabi_ul2d",
            "__aeabi_d2iz",
            "__aeabi_d2lz",
            "__aeabi_d2uiz",
            "__aeabi_d2ulz",
            "__aeabi_d2f",
            // Math functions
            "sqrt",
            "cos",
            "sin",
            "tan",
            "atan2",
            "exp",
            "log",
            "ldexp",
            "copysign",
            "trunc",
            "floor",
            "ceil",
            "round",
            "sincos",
            "asin",
            "acos",
            "atan",
            "sinh",
            "cosh",
            "tanh",
            "asinh",
            "acosh",
            "atanh",
            "exp2",
            "log2",
            "exp10",
            "log10",
            "pow",
            "powint",
            "hypot",
            "cbrt",
            "fmod",
            "drem",
            "remainder",
            "remquo",
            "expm1",
            "log1p",
            "fma",
        },
        else => &.{}, // Most components don't need wrapping
    };
}

fn getComponentSources(chip: Chip, cpu_arch: CpuArch, component: Component) []const []const u8 {
    return switch (component) {
        // Hardware peripherals
        .hardware_gpio => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/hardware_gpio/gpio.c",
            },
            .rp2350 => &.{
                "src/rp2_common/hardware_gpio/gpio.c",
                "zig/gpio_coproc_wrappers.c",
            },
        },
        .hardware_clocks => &.{
            "src/rp2_common/hardware_clocks/clocks.c",
        },
        .hardware_pll => &.{
            "src/rp2_common/hardware_pll/pll.c",
        },
        .hardware_xosc => &.{
            "src/rp2_common/hardware_xosc/xosc.c",
        },
        .hardware_watchdog => &.{
            "src/rp2_common/hardware_watchdog/watchdog.c",
        },
        .hardware_irq => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/hardware_irq/irq.c",
                "src/rp2_common/hardware_irq/irq_handler_chain.S",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/hardware_irq/irq.c",
                    "src/rp2_common/hardware_irq/irq_handler_chain.S",
                },
                .riscv => &.{
                    "src/rp2_common/hardware_irq/irq.c",
                    "src/rp2_common/hardware_irq/irq_handler_chain_riscv.S",
                },
            },
        },
        .hardware_sync => &.{
            "src/rp2_common/hardware_sync/sync.c",
            "src/rp2_common/hardware_sync_spin_lock/sync_spin_lock.c",
        },
        .hardware_timer => &.{
            "src/rp2_common/hardware_timer/timer.c",
        },
        .hardware_ticks => &.{
            "src/rp2_common/hardware_ticks/ticks.c",
        },
        .hardware_uart => &.{
            "src/rp2_common/hardware_uart/uart.c",
        },
        .hardware_spi => &.{
            "src/rp2_common/hardware_spi/spi.c",
        },
        .hardware_i2c => &.{
            "src/rp2_common/hardware_i2c/i2c.c",
        },
        .hardware_pwm => &.{}, // Header-only component
        .hardware_adc => &.{
            "src/rp2_common/hardware_adc/adc.c",
        },
        .hardware_dma => &.{
            "src/rp2_common/hardware_dma/dma.c",
        },
        .hardware_pio => &.{
            "src/rp2_common/hardware_pio/pio.c",
        },
        .hardware_flash => &.{
            "src/rp2_common/hardware_flash/flash.c",
        },
        .hardware_divider => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/hardware_divider/divider.S",
            },
            .rp2350 => &.{
                "src/rp2_common/hardware_divider/divider.c",
            },
        },
        .hardware_interp => &.{
            "src/rp2_common/hardware_interp/interp.c",
        },
        .hardware_exception => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/hardware_exception/exception.c",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/hardware_exception/exception.c",
                },
                .riscv => &.{
                    "src/rp2_common/hardware_exception/exception.c",
                    "src/rp2_common/hardware_exception/exception_table_riscv.S",
                },
            },
        },
        .hardware_resets => &.{}, // Header-only component
        .hardware_rtc => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/hardware_rtc/rtc.c",
            },
            .rp2350 => &.{}, // Not available on RP2350
        },
        .hardware_vreg => &.{
            "src/rp2_common/hardware_vreg/vreg.c",
        },
        .hardware_xip_cache => &.{
            "src/rp2_common/hardware_xip_cache/xip_cache.c",
        },

        // Platform and runtime
        .pico_platform => switch (chip) {
            .rp2040 => &.{
                "src/rp2040/pico_platform/platform.c",
                "src/rp2_common/pico_platform_common/common.c",
                "src/rp2_common/pico_platform_panic/panic.c",
                "zig/platform_wrappers.c",
            },
            .rp2350 => &.{
                "src/rp2350/pico_platform/platform.c",
                "src/rp2_common/pico_platform_common/common.c",
                "src/rp2_common/pico_platform_panic/panic.c",
                "zig/platform_wrappers.c",
            },
        },
        .pico_runtime => &.{
            "src/common/hardware_claim/claim.c",
            "src/rp2_common/pico_runtime/runtime.c",
        },
        .pico_runtime_init => &.{
            "src/rp2_common/pico_runtime_init/runtime_init.c",
            "src/rp2_common/pico_runtime_init/runtime_init_clocks.c",
            "src/rp2_common/pico_bootrom/bootrom.c",
            "src/rp2_common/hardware_vreg/vreg.c",
        },
        .pico_crt0 => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_crt0/crt0.S",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/pico_crt0/crt0.S",
                },
                .riscv => &.{
                    "src/rp2_common/pico_crt0/crt0_riscv.S",
                },
            },
        },
        .pico_time => &.{
            "src/common/pico_time/time.c",
            "src/common/pico_time/timeout_helper.c",
        },
        .pico_clib_minimal => &.{
            "src/rp2_common/pico_clib_interface/minimal_interface.c",
        },

        // Standard I/O
        .pico_stdio => &.{
            "src/rp2_common/pico_stdio/stdio.c",
        },
        .pico_stdio_uart => &.{
            "src/rp2_common/pico_stdio_uart/stdio_uart.c",
        },
        .pico_stdio_semihosting => &.{
            "src/rp2_common/pico_stdio_semihosting/stdio_semihosting.c",
        },

        // Multicore
        .pico_multicore => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_multicore/multicore.c",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/pico_multicore/multicore.c",
                },
                .riscv => &.{
                    "src/rp2_common/pico_multicore/multicore.c",
                    // RISC-V may need additional files
                },
            },
        },

        // Phase 2: Math and utility libraries
        .pico_printf => &.{
            "src/rp2_common/pico_printf/printf.c",
        },
        .pico_malloc => &.{
            "src/rp2_common/pico_malloc/malloc.c",
        },
        .pico_float => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_float/float_aeabi_rp2040.S",
                "src/rp2_common/pico_float/float_init_rom_rp2040.c",
                "src/rp2_common/pico_float/float_math.c",
                "src/rp2_common/pico_float/float_v1_rom_shim_rp2040.S",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/pico_float/float_math.c",
                    "src/rp2_common/pico_float/float_conv32_vfp.S",
                    "src/rp2_common/pico_float/float_common_m33.S",
                    "src/rp2_common/pico_float/float_sci_m33_vfp.S",
                },
                .riscv => &.{
                    "src/rp2_common/pico_float/float_single_hazard3.S",
                },
            },
        },
        .pico_double => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_double/double_aeabi_rp2040.S",
                "src/rp2_common/pico_double/double_init_rom_rp2040.c",
                "src/rp2_common/pico_double/double_math.c",
                "src/rp2_common/pico_double/double_v1_rom_shim_rp2040.S",
            },
            .rp2350 => switch (cpu_arch) {
                .arm => &.{
                    "src/rp2_common/pico_double/double_math.c",
                    "src/rp2_common/pico_double/double_aeabi_dcp.S",
                    "src/rp2_common/pico_double/double_fma_dcp.S",
                    "src/rp2_common/pico_double/double_sci_m33.S",
                    "src/rp2_common/pico_double/double_conv_m33.S",
                },
                .riscv => &.{}, // RISC-V uses compiler default
            },
        },
        .pico_divider => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_divider/divider_hardware.S",
            },
            .rp2350 => &.{
                "src/rp2_common/pico_divider/divider_compiler.c",
            },
        },
        .pico_int64_ops => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_int64_ops/pico_int64_ops_aeabi.S",
            },
            .rp2350 => &.{}, // RP2350 uses compiler default
        },
        .pico_bit_ops => &.{
            "src/rp2_common/pico_bit_ops/bit_ops_aeabi.S",
        },
        .pico_mem_ops => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_mem_ops/mem_ops_aeabi.S",
            },
            .rp2350 => &.{}, // RP2350 uses compiler default
        },
        .pico_rand => &.{
            "src/rp2_common/pico_rand/rand.c",
        },
        .pico_unique_id => &.{
            "src/rp2_common/pico_unique_id/unique_id.c",
        },
        .pico_bootrom => &.{
            "src/rp2_common/pico_bootrom/bootrom.c",
            "src/rp2_common/pico_bootrom/bootrom_lock.c",
        },
        .pico_atomic => &.{
            "src/rp2_common/pico_atomic/atomic.c",
        },
        .pico_sync => &.{
            "src/common/pico_sync/lock_core.c",
            "src/common/pico_sync/sem.c",
            "src/common/pico_sync/mutex.c",
            "src/common/pico_sync/critical_section.c",
        },
        .pico_stdlib => &.{
            "src/rp2_common/pico_stdlib/stdlib.c",
        },

        // Phase 3: RP2350-specific components
        .hardware_sha256 => switch (chip) {
            .rp2040 => &.{}, // Not available on RP2040
            .rp2350 => &.{
                "src/rp2_common/hardware_sha256/sha256.c",
            },
        },
        .hardware_powman => switch (chip) {
            .rp2040 => &.{}, // Not available on RP2040
            .rp2350 => &.{
                "src/rp2_common/hardware_powman/powman.c",
            },
        },
        .hardware_boot_lock => switch (chip) {
            .rp2040 => &.{}, // Not available on RP2040
            .rp2350 => &.{
                "src/rp2_common/hardware_boot_lock/boot_lock.c",
            },
        },
        .pico_sha256 => switch (chip) {
            .rp2040 => &.{}, // Not available on RP2040
            .rp2350 => &.{
                "src/rp2_common/pico_sha256/sha256.c",
            },
        },

        // Phase 5: Async context and additional utilities
        .pico_async_context_base => &.{
            "src/rp2_common/pico_async_context/async_context_base.c",
        },
        .pico_async_context_poll => &.{
            "src/rp2_common/pico_async_context/async_context_poll.c",
        },
        .pico_async_context_threadsafe_background => &.{
            "src/rp2_common/pico_async_context/async_context_threadsafe_background.c",
        },
        .pico_flash => &.{
            "src/rp2_common/pico_flash/flash.c",
        },
        .pico_i2c_slave => &.{
            "src/rp2_common/pico_i2c_slave/i2c_slave.c",
        },
        .pico_aon_timer => &.{
            "src/rp2_common/pico_aon_timer/aon_timer.c",
        },
        .hardware_sync_spin_lock => &.{
            "src/rp2_common/hardware_sync_spin_lock/sync_spin_lock.c",
        },

        // Phase 4: USB support
        .pico_stdio_usb => &.{
            "src/rp2_common/pico_stdio_usb/stdio_usb.c",
            "src/rp2_common/pico_stdio_usb/reset_interface.c",
            "src/rp2_common/pico_stdio_usb/stdio_usb_descriptors.c",
        },
        .pico_fix_rp2040_usb_device_enumeration => switch (chip) {
            .rp2040 => &.{
                "src/rp2_common/pico_fix/rp2040_usb_device_enumeration/rp2040_usb_device_enumeration.c",
            },
            .rp2350 => &.{}, // Not needed on RP2350
        },
    };
}
